function [outdata, tbase, out_rate, err] = pulse(varargin)
% pulse: Method to generate pulse train waveforms
% Usage
%     Not normally called directly by the user

% PULSEGEN - create pulse train waveform
%
%    PULSEGEN produces a pulse train waveform pulse_out
%    specified by the parameters in the structure sfile.
%
%    The stimulus structure is generated by new.m.
%		The following parameters are required:
%   sfile.Npulses= number of pulses in the train
%   sfile.Delay= delay to first pulse
%   sfile.IPI= interpulse interval (one number)
%   sfile.Duration = duration list for pulses (compound pulses allowed at each interval)
%   sfile.Level= level list for pulses (compound levels corresponding to durations)
%   sfile.LevelFlag= 'absolute' or 'relative': levels after first are either absolute or relative
%   sfile.Scale= scale factor applied to output
%	 sfile.Offset = offset added to output (after scaling)
%   sfile.Sequence= sequence (operates as in steps - multiple seqeuences allowed)
%   sfile.SeqParList= parameters to sequence (apply according to entries in sequence)
%   sfile.SeqStepList= which step to be operated on by the sequence element if level or duration
%
%
% original by S.C. Molitor, 8/2000
% modified Paul B. Manis, Ph.D.
% pmanis@med.unc.edu
% 9/1/2000   uses new record_parse and step generator
%
% Revised 4/10/2008 to use new methods.
% - call with no arguments tests the algorithm.
% - uses state matrix to drive sequencing.

% initialize output
outdata = {};
err = 0;
tbase = {};
out_rate = [];

if(nargin == 0) % test mode...
    sfile = new('pulse');
else
    sfile = varargin{1};
    if(isempty(sfile))
        QueMessage('pulse: No STIM?', 1);
        return;
    end;
    if(~strcmp(sfile.Method.v, 'pulse'))
        QueMessage(sprintf('pulse: loaded sfile is of type %s, not ours!', sfile.Method.v), 1);
        return;
    end;
end;

% define the potential variables that can be sequenced and confirm that
% args are ok
possible_sequences = {'level', 'duration', 'ipi'};
levpos = 1;
durpos = 2;
ipipos = 3;
if(chklength(sfile, possible_sequences, ones(length(possible_sequences), 1)))  % make sure incoming arguments are acceptable
    return;
end;

% check the parameters to be sequenced to be sure they are valid also
% seqflags is an nxm array of 0's and 1's
% iterating each row tells you which sequence parameter is being run (by
% column entry)
% successive rows are nested sequences.
% first index is row, second is column.
[seqflags, errp] = chkpars(sfile.SeqParList.v, possible_sequences);
if(errp)
    return;
end;
% compute the sequences
thisseq = strrep(sfile.Sequence.v, ' ', '');
if(~isempty(thisseq))
    [vlist, nlist]=seq_parse(thisseq); % partition list. Result is cell array, fastest first.
    if(isempty(vlist))
        err = 1;
        return;
    end;
else
    vlist{1}= 0;
end;
nout = prod(nlist);

% at this point, the basic parameters appear to be valid.
% compute some base values

out_rate=(1000000/eval('sfile.Sample_Rate.v')); % convert to samples per second (rate in usec)
% note factor of 2 is to allow for using the second channel simultaneously...

base_dur = eval('sfile.Duration.v'); % get basic duration list
base_lev = eval('sfile.Level.v'); % get basic level list
base_ipi = eval('sfile.IPI.v'); % base IPI list
nrate = eval('sfile.Sample_Rate.v'); % sample rate, in microseconds (note divisions below!)

% total duration of longest stimulus
tot_dur = sfile.Delay.v + (sfile.Npulses.v+1)*(max(base_ipi)+sum(base_dur)); % (dur is in msec).
npts = floor(0.5+tot_dur/(nrate/1000));  % points in the array


% check the level flag.
if (strcmpi(sfile.LevelFlag.v, 'relative'))
    relflag = 1;
elseif (strcmpi(sfile.LevelFlag.v, 'absolute'))
    relflag = 0; % means nothing - just a place holder
else % error
    QueMessage('pulse: LevelFlag must be ''relative'' or ''absolute''\n', 1);
    return
end

outdata = cell(nout, 1);
tbase = cell(nout, 1);

% generate ONE waveform for scope mode
outdata{1}.vsco=zeros(1,npts);
tbase{1}.vsco=nrate*(0:npts-1)/1000; % time base, in msec for the output
sdel = floor(sfile.Delay.v/(nrate/1000))*nrate/1000;

if(length(base_ipi) > 1) % compute step start times, according to npulses and ipi
    bipi = floor(base_ipi(1)/(nrate/1000))*nrate/1000;
else
    bipi = floor(base_ipi/(nrate/1000))*nrate/1000;
end;
pulse_begin = sdel + (0 : sfile.Npulses.v - 1) * bipi;

for n = 1 : length(pulse_begin) % for each pulse in the train
    k = floor(pulse_begin(n)/(nrate/1000))+1; % get the index of start of pulse
    j = 0;
    lev=[];
    j1 = 1;
    for i=1:length(sfile.Duration.v) % each pulse consists of a series of steps, so create steps
        j2 = floor(sfile.Duration.v(i)/(nrate/1000)); % Number of points in the duration step dur in msec; convert rate to msec too
        if(relflag && i > 1) % check relative
           lev(j1:j1+j2-1)  = sfile.Level.v(1)*sfile.Level.v(i); % value is constant for that time
        else
           lev(j1:j1+j2-1) = sfile.Level.v(i);
        end;
        j1 = j2 + 1;
    end;
    outdata{1}.vsco(k:k+length(lev)-1) = lev;
end
outdata{1}.vsco = outdata{1}.vsco * sfile.Scale.v + sfile.Holding.v; % scale and offset the data

% create pulsetrain template from levels & durations

for m = 1:nout % for each element of the sequence
    outdata{m}.v=zeros(1,npts);
    mipi = mod(m, ipipos);

    % build pulse train template
    if(any(seqflags(:, ipipos))) % compute step start times, according to npulses and ipi
        pulse_begin = sdel + (0 : sfile.Npulses.v  - 1) * vlist{find(seqflags(:,ipipos))}(m);
    else
        pulse_begin = sdel + (0 : sfile.Npulses.v - 1) * bipi; % single pulse.
    end;
    lev = [];
    [lev] = pulsegenerate(sfile.Duration.v, sfile.Level.v, relflag, nrate);

    for i = 1 : length(pulse_begin) % for each pulse in the train
        k = floor(pulse_begin(i)/(nrate/1000))+1; % get the index of start of pulse
        j = length(lev); % subtract one for counting...
        % first, is this step variable at all?
        outdata{m}.v(k:k+j-1) = lev; % value is constant for that time
        if(any(seqflags(:,durpos))) % duration is being sequenced
            j = floor(vlist{find(seqflags(:,durpos))}(m)/nrate);
            outdata{m}.v(k:k+j-1) = lev; % value is constant for that time
        end;            % note that if both are sequenced, order is important!
        if(any(seqflags(:, levpos))) % level is being sequenced for this step
            levlist = sfile.Level.v;
            lpos = find(seqflags(:,levpos));
            levlist(lpos) = vlist{lpos}(m);
            levls = pulsegenerate(sfile.Duration.v, levlist, relflag, nrate);
            outdata{m}.v(k:k+j-1) = levls;
        end;
    end;


    outdata{m}.v = outdata{m}.v*sfile.Scale.v + sfile.Holding.v; % scale and offset the data
    tbase{m}.v=nrate*(0:length(outdata{m}.v)-1)/1000; % time base, in msec for the output
end; % done with generating the pulse train waveform set

%check for superposition, and do it if necessary
if(~isempty(sfile.Superimpose.v))
    [outdata, tbase, out_rate, err] = combine(outdata, tbase, out_rate, sfile, 'superimpose');
    if(err)
        return;
    end;
end;
% and the second channel information
if(~isempty(unblank(sfile.Addchannel.v)))
    [outdata, tbase, out_rate, err] = combine(outdata, tbase, out_rate, sfile, 'addchannel');
    if(err)
        return;
    end;
end;

if(nargin == 0)
    teststimplot(tbase, outdata, 0);
end;

err = 0; % only clear error flag if we make it all the way through.

return

function [lev] = pulsegenerate(Duration, Level, relflag, nrate)
j1 = 1;
    for p = 1:length(Duration) % each pulse consists of a series of steps, so create steps
        j2 = floor(Duration(p)/(nrate/1000)); % Number of points in the duration step dur in msec; convert rate to msec too
        if(relflag && i > 1) % check relative
            lev(j1:j1+j2-1)  = Level(1)*Level(p); % value is constant for that time
        else
            lev(j1:j1+j2-1) = Level(p);
        end;
        j1 = j2 + 1;
    end;